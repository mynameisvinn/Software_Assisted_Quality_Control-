function predictions_array = generate_predictions_array(datafileid)


    %% Step 1: connect to limsdb
    conn = database('limsdb','lims','mou53Brains!');
    curs = exec(conn,[]);
    data_id = datafileid;

    % retreive path
    sql = ['SELECT primary_file_system_location_lossy FROM data_file WHERE id = "' num2str(data_id) '"'];
    curs = exec(conn,sql);
    curs = fetch(curs);
    imagefilename = curs.Data;
    path = strcat('Z:\Converted Image Data\', imagefilename);

    %% Step 2: generate predictions

    im0 = imread(char(path));

    % recast from uint16 to uint8
    im1 = uint8(im0);

    % convert rgb to hsv colorspace
    im2 = rgb2hsv(im1);

    % extract hue
    % 1st plane is hue; 2nd is saturation; 3rd is value
    % https://www.mathworks.com/help/matlab/ref/rgb2hsv.html
    im3 = im2(:,:,1);

    % convert to a hue angle, which is required for color subsetting
    % https://www.mathworks.com/matlabcentral/answers/8058-hue-value-of-image-image-processing-in-matlab-rgb-to-hsv
    im4 = im3 .* 360;

    % cast im4 (double) to im5 (int8)
    im5 = uint8(im4);

    % create orange hue mask (values of [5,65]
    % keep this larger band for reddish NMJs
    % http://www.color-blindness.com/color-name-hue/
    im6 = (im5 < 65 & im5 > 5);

    % recast im6 to int8 create a mask
    im7 = uint8(im6);

    % j1 is the red channel, as subsetted from original rgb image
    j1 = im1(:,:,1);

    % extract regions that satisfy hue mask
    % j2 represents regions of red channel that satisfies hue mask
    j2 = j1 .* im7;

    % now, lets create saturation mask
    % keep pixels where saturation > 75%
    % lowering saturation threshold will increase FPs dramatically
    h1 = im2(:,:,2);
    h2 = h1 > .75;
    h3 = uint8(h2);

    % j3 represents regions of red channel that satisfies both hue mask AND saturation mask
    j3 = j2 .* h3;

    % j4 represents regions of j3 with high red intensities
    j4 = j3 > 150;

    % for weightedcentroids calculation, => mask (logic) first, followed by grayscale channel
    tmr_predictions_1 = regionprops(j4, j3, 'WeightedCentroid', 'Area');

    %% Step 3: minimize TMR FPs

    % size filter to remove smaller image artifacts
    % tightening the size condition substantially reduces FPs
    tmr_predictions_2 = tmr_predictions_1([tmr_predictions_1.Area] >150);

    % preallocate structure for subsetted TMR predictions
    tmr_predictions_3 = repmat(struct('Area',0, 'WeightedCentroid', 0), 5, 1);
    tmr_predictions_3_counter = 1;

    for index_i_1 = 1:length(tmr_predictions_2)

        % collect coordinates from TMR predictions
        a = round(tmr_predictions_2(index_i_1).WeightedCentroid(1));
        b = round(tmr_predictions_2(index_i_1).WeightedCentroid(2));

        % generate image patch for TMR prediction
        tile_red = im1(b - 25: b+ 25, a - 25: a + 25, 1);

        % threshold to find black regions
        tile_bw = tile_red < 40;

        % calculate percentage of dark regions
        percentage_black = sum(tile_bw(:)) / 40000; % denominator reflects tile dimensions (200x200)

        % copy if percentage_black is acceptable
        if percentage_black < .8;
            tmr_predictions_3(tmr_predictions_3_counter) = tmr_predictions_2(index_i_1);
            tmr_predictions_3_counter = tmr_predictions_3_counter + 1;
        end
    end


    %% Step 4: extract TMR predictions from structure

    % preallocate arrays
    tmr_predictions_x = zeros(length(tmr_predictions_3), 1);
    tmr_predictions_y = zeros(length(tmr_predictions_3), 1);
    tmr_predictions_tileID = zeros(length(tmr_predictions_3), 1);

    % grab dimensions for tileID calc
    [height, width, z] = size(im1);

    % populate arrays with coordinates of TMR predictions
    for index_i_2 = 1:length(tmr_predictions_3)

        tmr_predictions_x(index_i_2) = round(tmr_predictions_3(index_i_2).WeightedCentroid(1));
        tmr_predictions_y(index_i_2) = round(tmr_predictions_3(index_i_2).WeightedCentroid(2));
        tmr_predictions_tileID(index_i_2) = CoordinatesToTileNumber(round(tmr_predictions_3(index_i_2).WeightedCentroid(1)),round(tmr_predictions_3(index_i_2).WeightedCentroid(2)),width ,height);

    end

    % zip arrays
    tmr_predictions_4 = cat(2, tmr_predictions_x, tmr_predictions_y, tmr_predictions_tileID);
    csvwrite('tmr_predictions.csv', tmr_predictions_4)

    %% Step 5: generate patches

    TMR_patch_size = 50;
    VACHT_patch_size = 25;

    for index_i_6 = 1:length(tmr_predictions_4)

        a = round(tmr_predictions_4(index_i_6,1));
        b = round(tmr_predictions_4(index_i_6,2));

        % create TMR patches

        tmr_patch = im1(b-TMR_patch_size: b +TMR_patch_size, a - TMR_patch_size: a + TMR_patch_size,:);
        tmr_filename = strcat('TMR_', int2str(data_id), '_', int2str(index_i_6),'.tif');
        imwrite(tmr_patch, tmr_filename, 'tif');

        % create VACHT patches

        VACHT_patch = im1(b-VACHT_patch_size: b +VACHT_patch_size, a - VACHT_patch_size: a + VACHT_patch_size,:);  
        VACHT_patch(:,:,1) = 0;
        VACHT_patch(:,:,3) = 0;
        VACHT_filename = strcat('VACHT_', int2str(data_id), '_', int2str(index_i_6),'.tif');
        imwrite(VACHT_patch, VACHT_filename, 'tif');

    end
    
end


